\documentclass[a4paper, 11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{verbatim}
\begin{document}

\title{Projet d'Algorithmique}
\author{David Galichet et Baptiste Fontaine}
\date{29 novembre 2013}
\maketitle
\tableofcontents
\newpage


\part{Implémentation}

Le projet a été écrit avec Python 3 sans utilisation de bibliothèques externes.
Il est versionné avec Git et sera disponible en ligne après la soutenance.

\section{Mise en route}
\subsection{Installation}

Le code est situé dans \verb|src|, et ne nécessite pas d'installation
particulière. Assurez-vous cependant d'avoir au moins Python 3.1.

Un \verb|Makefile| est fourni afin de compiler le présent rapport et de faire
tourner la suite de tests.

\subsection{Utilisation}

Le programme s'appelle \verb|wrapper|, il suffit de le lancer avec l'option
\verb|--help| pour avoir un aperçu de son utilisation ainsi qu'une liste des
algorithmes disponibles. Il lit son entrée sur l'entrée standard, et écrit le
résultat sur la sortie standard. Il est possible de choisir l'algorithme à
utiliser en utilisant l'option \verb|--algo|, ainsi que de changer la largeur
de la page (79 par défaut) avec \verb|-w|. Le texte en sortie peut être
justifié avec la l'option \verb|--justify|.

Par exemple, pour utiliser l'algorithme \ref{sec:simple-greedy} avec une largeur
de page de 76 pour un texte situé dans \verb|in.txt|, utilisez la ligne suivante
:

\begin{verbatim}
./wrapper --algo greedy -w 76 < in.txt
\end{verbatim}

Il est également possible d'obtenir plus d'informations sur un algorithme en
utilisant l'option \verb|--info|.

\begin{verbatim}
./wrapper --info greedy
\end{verbatim}

\section{Fonctionnement}

Un des avantages de Python par rapport aux autres langages proposés pour le
projet est qu'il a des fonctions de première classe. Nous avons utilisé cette
fonctionalité ainsi que le chargement dynamique de modules pour avoir un
environnement permettant de très facilement ajouter ou enlever des algorithmes
sans avoir à modifier aucune autre partie du code que la fonction qui définit
l'algorithme.

Lors du lancement du programme, tous les modules Python situés dans
\verb|src/algos| sont chargés et les implémentations d'algorithmes qu'ils
contiennent sont enregistrées dans une table de correspondance, qui associe leur
nom avec leur fonction et la documentation optionnelle. En fonction
des options données sur la ligne de commande, le programme utilise ensuite cette
table pour afficher la liste des algorithmes possibles, afficher la
documentation de l'un d'eux ou l'exécuter sur du texte donné en entrée.

Chaque algorithme est défini sous forme d'une fonction qui prend en argument une
liste paresseuse de mots (un générateur) et une largeur, et génère une liste
de lignes qui correspond au texte imprimé sur une page de la largeur donnée.
Nous utilisons les décorateurs de Python pour différencier les fonctions qui
implémentent des algorithmes des fonctions auxilliaires. Chaque ligne est
retournée comme une liste de mots, de façon à simplifier l'éventuelle
justification.

Voici par exemple ce que serait le code déclarant un algorithme qui affiche un
mot par ligne, peut importe la largeur de la page :

\begin{verbatim}
@algo("An example algorithm")
def one_word_per_line(words, width):
    """
    This algorithm is an example,
    don't use it! It outputs only one word
    per line.
    """
    for word in words:
        yield [word]
\end{verbatim}

Cet algorithme pourrait ensuite être utilisé sur la ligne de commande :

\begin{verbatim}
$ ./wrapper --info one-word-per-line
One Word Per Line: An example algorithm

    This algorithm is an example,
    don't use it! It outputs only one word
    per line.

$ echo foo bar | ./wrapper -a one-word-per-line -w 42
foo
bar
\end{verbatim}

\part{Algorithmes}

Les algorithmes sont regroupés par familles, telles que vues en cours.
La complexité théorique dans le pire des cas est donnée en fonction de la
longueur du texte en entrée ($n$) et de la largeur maximale d'une ligne ($k$).

Dans le cas particulier où un mot serait plus long que la largeur de la page, on
ne renvoit pas d'erreur, mais on laisse le mot tel quel sur une ligne. C'est à
l'utilisateur de prévoir ce type de cas.

Nous avons ajouté une méthode de justification du texte (i.e. insertion
d'espaces entre les mots de façon à ce que chaque ligne prenne la place
maximale) qui s'applique en repassant sur le texte formatté. Cette méthode est
décrite dans la section \ref{sec:justification}.

\section{Diviser pour régner}

\subsection{Diviser pour régner naïf}

Cet algorithme est une implémentation naïve du principe de « diviser pour régner
», en effet il ne fait que diviser récursivement le texte donné en entrée
jusqu'à ce que chaque partie puisse tenir sur une ligne. Il ne fonctionne donc
que sur des textes de longueur raisonnable puisque sa complexité en mémoire est
en $O(n)$ car tout le texte doit être lu avant de pouvoir le diviser. L'utilité
du « diviser pour régner » est discutable ici, puisque tous les mots doivent
être lus car il faut connaître leur longueur. La complexité n'est donc pas
réduite par l'utilisation de ce type d'algorithme. Elle est de
$O(n+\log_2 n) \in O(n)$ (parcours de l'ensemble du texte en entrée et division
du tableau).

\section{Gloutons}

\subsection{Glouton}
\label{sec:simple-greedy}

Cet algorithme, qui marche en $O(n)$ ($O(k)$ pour la mémoire), est le plus
intuitif et le plus simple à implémenter. Il ajoute tous les mots à la suite
tant qu'il a assez de place sur une ligne, puis passe à la suivante.

Utilisez \verb|greedy| pour tester l’algorithme.

\subsection{Glouton balancé}
\label{sec:balanced-greedy}

Cet algorithme utilise « Glouton simple » (\ref{sec:simple-greedy}), balance les
espaces entre les mots selon une interprétation de la méthode de Samet
\cite{Samet82}. Dans son article, Hanan Samet propose plusieurs mesures pour
balancer les espaces entre les mots pour un texte justifié. Nous avons pris la
moyenne $m$ des largeurs de ces espaces sur l'ensemble du texte s'il était
justifié, puis avons fixé l'espace inter-mots de l'ensemble du texte à
$\lfloor m \rfloor$. Enfin, l'algorithme « Glouton simple » est de nouveau
appliqué car le balancement des espaces peut avoir bougé des mots entre les
lignes. Il est possible de tester cet algorithme avec \verb|balanced-greedy|. Il
marche en $O(3n)$ et $O(n)$ en mémoire. Le résultat est généralement moins bon
visuellement qu'avec \ref{sec:simple-greedy} car il y a plus d'espaces et plus
de lignes utilisées.

\section{Programmation dynamique}


% TODO partie "[pour] aller plus loin" ?

\section{Justification}
\label{sec:justification}

Bien que la justification de texte puisse poser des problèmes de lecture
\cite{Van96cognitive}, notamment à cause de l'insertion de nombreux espaces
entre les mots, ce qui peut créer des « rivières\footnote{En typographie, les
« rivières » (ou « lézardes ») sont des suites verticales d'espaces entre les
mots qui forment des chemins blancs dans le texte et distraient
l'œil\cite{Harkins12fr}} » et des trous blancs, il nous a parut intéressant de
nous pencher sur ce problème. La justification se fait une fois tous les mots
disposés sur les lignes en ajustant les espaces inter-mots de façon à ce que le
texte soit aligné aussi bien à gauche qu'à droite. Nous avons testé deux
méthodes mais n'avons gardé que la première car la seconde donnait du texte avec
trop d'espaces.

\begin{enumerate}
    \item Méthode simple : Cette méthode fonctionne ligne par ligne. Elle
        calcule le nombre d'espaces en trop en fin de ligne et les répartie
        équitablement entre les mots de gauche à droite. Si le nombre d'espaces
        de fin de ligne n'est pas divisible par le nombre d'inter-mots, on
        ajoute un espace de plus au nombre nécessaire d'inter-mots de façon à ce
        qu'ils soient tous répartis. Cet algorithme de justification peut être
        utilisé sur la ligne de commande via l'option \verb|--justify|.
        Il ajoute une complexité en $O(2n)$ en temps (il passe une première fois
        sur une ligne pour calculer le nombre d'espaces à sa fin, puis une
        seconde pour les répartir, et ce pour chaque ligne), et $O(k)$ en
        mémoire puisqu'il ne garde qu'une seule ligne en mémoire à chaque fois.
    \item Méthode dynamique : Cette méthode regarde l'ensemble du paragraphe
        plutôt que ligne par ligne. Contrairement à la précédente qui laisse les
        mots sur leur ligne, elle peut déplacer des mots entre les lignes. Elle
        consiste à calculer la moyenne des largeurs des espaces entre mots de
        tout le texte si celui-ci était justifié avec la première méthode, puis
        de parcourir celui-ci pour ajuster les espaces afin de les rapprocher de
        la moyenne. Cet algorithme représente notre interprétation de la méthode
        de Hanan Samet\footnote{Hanan Samet propose plusieurs heuristiques pour
        déterminer l'uniformité d'un paragraphe, ainsi que des algorithmes pour
        l'améliorer. Nous ne nous sommes intéressés qu'aux heuristiques et avont
        implémenté un algorithme en s'inspirant de celles-ci} pour découper les
        lignes d'un texte \cite{Samet82}. La façon dont nous l'avions implémenté
        donnait des lignes avec beaucoup trop d'espaces entre les mots dans
        certains cas, nous l'avons donc adapté pour écrire l'algorithme
        \ref{sec:balanced-greedy}.
\end{enumerate}

\section{Récapitulatif}

% TODO tableau des benchmarks + récapitulatif des complexités

\newpage
\bibliographystyle{plain}
\bibliography{rapport}
\end{document}
