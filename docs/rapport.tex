\documentclass[a4paper, 11pt]{article}
%\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
%\usepackage{cprotect}
\usepackage{verbatim}
\begin{document}

\title{Projet d'Algorithmique}
\author{David Galichet et Baptiste Fontaine}
\date{28 novembre 2013}
\maketitle

\part{Implémentation}

Le projet a été écrit avec Python 3 sans utilisation de bibliothèques externes.

\section{Mise en route}
\subsection{Installation}

Le code est situé dans \verb|src|, et ne nécessite pas d'installation
particulière. Assurez-vous cependant d'avoir au moins Python 3.1.

\subsection{Utilisation}

Le programme s'appelle \verb|wrapper|, il suffit de le lancer avec l'option
\verb|--help| pour avoir un aperçu de son utilisation ainsi qu'une liste des
algorithmes disponibles. Il lit son entrée sur l'entrée standard, et écrit le
résultat sur la sortie standard. Il est possible de choisir l'algorithme à
utiliser en utilisant l'option \verb|--algo|, ainsi que de changer la largeur
de la page (79 par défaut) avec \verb|-w|.

Par exemple, pour utiliser l'algorithme « naive-greedy » avec une largeur de
page de 76 pour un texte situé dans \verb|in.txt|, utilisez la ligne suivante :

\begin{verbatim}
./wrapper --algo naive-greedy -w 76 < in.txt
\end{verbatim}

Il est également possible d'obtenir plus d'informations sur un algorithme en
utilisant l'option \verb|--info|.

\begin{verbatim}
./wrapper --info naive-greedy
\end{verbatim}

\section{Fonctionnement}

Un des avantages de Python par rapport aux autres langages proposés pour le
projet est qu'il a des fonctions de première classe. Nous avons utilisé cette
fonctionalité ainsi que du chargement dynamique de modules pour avoir un
environnement permettant de très facilement ajouter ou enlever des algorithmes
sans avoir à modifier aucune autre partie du code que la fonction qui définit
l'algorithme.

Lors du lancement du programme, tous les modules Python situés dans
\verb|src/algos| sont chargés et les implémentations d'algorithmes qu'ils
contiennent sont enregistrées dans une table de correspondance, qui associe leur
nom avec la fonction qui correspond et la documentation optionnelle. En fonction
des options données sur la ligne de commande, le programme utilise ensuite cette
table pour afficher la liste des algorithmes possibles, afficher la
documentation de l'un d'eux ou l'exécuter sur du texte donné en entrée.

Chaque algorithme est défini sous forme d'une fonction qui prend en argument une
liste paresseuse de mots (un générateur) et une largeur, et génère une liste
de lignes qui correspond au texte imprimé sur une page de la largeur donnée.
Nous utilisons les décorateurs de Python pour différencier les fonctions qui
implémentent des algorithmes des autres. Chaque ligne est retournée comme une
liste de mots, de façon à simplifier l'éventuelle justification.

Voici par exemple ce que serait le code déclarant un algorithme qui affiche un
mot par ligne, peut importe la largeur de la page :

\begin{verbatim}
@algo("An example algorithm")
def one_word_per_line(words, width):
    """
    This algorithm is an example,
    don't use it! It outputs only one word
    per line.
    """
    for word in words:
        yield word
\end{verbatim}

\part{Algorithmes}

Les algorithmes sont regroupés par familles, telles que vues en cours. Ils sont
tous, sauf exception, implémentés de façon à fonctionner sur un flux de texte,
ce qui impliquent qu'ils fonctionnent sur un flux infini de texte sans problème.
La complexité théorique dans le pire des cas est donnée en fonction de la
longueur du texte en entrée ($n$) et de la largeur maximale d'une ligne ($k$).

\section{Diviser pour régner}

\subsection{Diviser pour régner naïf}

Cet algorithme est une implémentation naïve du principe de « diviser pour régner
», en effet il ne fait que diviser récursivement le texte donné en entrée
jusqu'à ce que chaque partie puisse tenir sur une ligne. Il ne fonctionne donc
que sur des textes de longueur raisonnable puisque sa complexité en mémoire est
en $O(n)$. % TODO continuer

\section{Gloutons}

\subsection{Glouton simple}

Cet algorithme, qui marche en $O(n)$ ($O(k)$ pour la mémoire, qu'on pourrait
réduire à $O(1)$ car la ligne courante n'est gardée en mémoire que dans le but
de mettre la sortie en tampon), est probablement le plus basique, celui qui
vient tout de suite à l'esprit lorsque le problème nous est présenté. Il ajoute
chaque mot sur la même ligne que le précédent, et si la longueur de la ligne
avec ce mot dépasse la longueur maximale, il l'ajoute sur la ligne suivante et
continue sur celle-ci.

Il ne fait que maximiser le nombre de mots par ligne, mais ne cherche pas à
ajouter des espaces entre les mots de façon à justifier le texte.

Utilisez \verb|simple-greedy| pour tester l’algorithme.

% \subsection{Glouton naïf avec justification}
% 
% Cet algorithme est identique à « Glouton naïf » sauf qu'il exécute une seconde
% passe sur chaque ligne pour ajouter des espaces entre les mots de façon à
% supprimer les espaces en fin de ligne. Il fonctionne donc en $O(2n)$ en temps et
% $O(k)$ en mémoire, et, s'il diminue le nombre total d'espaces en fin de lignes,
% il diminue la lisibilité du texte par rapport à l'algorithme sur lequel il
% s'appuit car il ne coupe pas les mots entre deux lignes, donc certaines lignes
% ont beaucoup d'espaces entre les mots.
%
%Utilisez \verb|naive-greedy-justify| pour tester l’algorithme.

\section{Programmation dynamique}

\section{Récapitulatif}

\bibliographystyle{plain}
\bibliography{rapport}
\end{document}
