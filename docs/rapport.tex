\documentclass[a4paper, 11pt]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
%\usepackage{cprotect}
\usepackage{verbatim}
\begin{document}

\title{Projet d'Algorithmique}
\author{David Galichet et Baptiste Fontaine}
\date{28 novembre 2013}
\maketitle
\tableofcontents
\newpage


\part{Implémentation}

Le projet a été écrit avec Python 3 sans utilisation de bibliothèques externes.
Il est versionné avec Git et sera disponible en ligne après la soutenance.

\section{Mise en route}
\subsection{Installation}

Le code est situé dans \verb|src|, et ne nécessite pas d'installation
particulière. Assurez-vous cependant d'avoir au moins Python 3.1.

\subsection{Utilisation}

Le programme s'appelle \verb|wrapper|, il suffit de le lancer avec l'option
\verb|--help| pour avoir un aperçu de son utilisation ainsi qu'une liste des
algorithmes disponibles. Il lit son entrée sur l'entrée standard, et écrit le
résultat sur la sortie standard. Il est possible de choisir l'algorithme à
utiliser en utilisant l'option \verb|--algo|, ainsi que de changer la largeur
de la page (79 par défaut) avec \verb|-w|. Le texte en sortie peut être
justifié avec la l'option \verb|--justify| (voir l'aide pour les valeurs
possibles).

Par exemple, pour utiliser l'algorithme « naive-greedy » avec une largeur de
page de 76 pour un texte situé dans \verb|in.txt|, utilisez la ligne suivante :

\begin{verbatim}
./wrapper --algo naive-greedy -w 76 < in.txt
\end{verbatim}

Il est également possible d'obtenir plus d'informations sur un algorithme en
utilisant l'option \verb|--info|.

\begin{verbatim}
./wrapper --info naive-greedy
\end{verbatim}

\section{Fonctionnement}

Un des avantages de Python par rapport aux autres langages proposés pour le
projet est qu'il a des fonctions de première classe. Nous avons utilisé cette
fonctionalité ainsi que le chargement dynamique de modules pour avoir un
environnement permettant de très facilement ajouter ou enlever des algorithmes
sans avoir à modifier aucune autre partie du code que la fonction qui définit
l'algorithme.

Lors du lancement du programme, tous les modules Python situés dans
\verb|src/algos| sont chargés et les implémentations d'algorithmes qu'ils
contiennent sont enregistrées dans une table de correspondance, qui associe leur
nom avec leur fonction et la documentation optionnelle. En fonction
des options données sur la ligne de commande, le programme utilise ensuite cette
table pour afficher la liste des algorithmes possibles, afficher la
documentation de l'un d'eux ou l'exécuter sur du texte donné en entrée.

Chaque algorithme est défini sous forme d'une fonction qui prend en argument une
liste paresseuse de mots (un générateur) et une largeur, et génère une liste
de lignes qui correspond au texte imprimé sur une page de la largeur donnée.
Nous utilisons les décorateurs de Python pour différencier les fonctions qui
implémentent des algorithmes des fonctions auxilliaires. Chaque ligne est
retournée comme une liste de mots, de façon à simplifier l'éventuelle
justification.

Voici par exemple ce que serait le code déclarant un algorithme qui affiche un
mot par ligne, peut importe la largeur de la page :

\begin{verbatim}
@algo("An example algorithm")
def one_word_per_line(words, width):
    """
    This algorithm is an example,
    don't use it! It outputs only one word
    per line.
    """
    for word in words:
        yield [word]
\end{verbatim}

\part{Algorithmes}

Les algorithmes sont regroupés par familles, telles que vues en cours.
La complexité théorique dans le pire des cas est donnée en fonction de la
longueur du texte en entrée ($n$) et de la largeur maximale d'une ligne ($k$).

Dans le cas particulier où un mot serait plus long que la largeur de la page, on
ne renvoit pas d'erreur, mais on laisse le mot tel quel sur une ligne. C'est à
l'utilisateur de prévoir ce type de cas.

Nous avons ajouté deux méthodes de justification du texte (i.e. insertion
d'espaces entre les mots de façon à ce que chaque ligne prenne la place
maximale) qui s'appliquent en repassant sur le texte formatté. Ces méthodes
sont décrites dans la section \ref{sec:justification}.

\section{Diviser pour régner}

\subsection{Diviser pour régner naïf}

Cet algorithme est une implémentation naïve du principe de « diviser pour régner
», en effet il ne fait que diviser récursivement le texte donné en entrée
jusqu'à ce que chaque partie puisse tenir sur une ligne. Il ne fonctionne donc
que sur des textes de longueur raisonnable puisque sa complexité en mémoire est
en $O(n)$. % TODO continuer

\section{Gloutons}

\subsection{Glouton simple}

Cet algorithme, qui marche en $O(n)$ ($O(k)$ pour la mémoire), est le plus
intuitif et le plus simple à implémenter. Il ajoute tous les mots à la suite
tant qu'il a assez de place sur une ligne, puis passe à la suivante.

Utilisez \verb|simple-greedy| pour tester l’algorithme.

% \subsection{Glouton naïf avec justification}
% 
% Cet algorithme est identique à « Glouton naïf » sauf qu'il exécute une seconde
% passe sur chaque ligne pour ajouter des espaces entre les mots de façon à
% supprimer les espaces en fin de ligne. Il fonctionne donc en $O(2n)$ en temps et
% $O(k)$ en mémoire, et, s'il diminue le nombre total d'espaces en fin de lignes,
% il diminue la lisibilité du texte par rapport à l'algorithme sur lequel il
% s'appuit car il ne coupe pas les mots entre deux lignes, donc certaines lignes
% ont beaucoup d'espaces entre les mots.
%
%Utilisez \verb|naive-greedy-justify| pour tester l’algorithme.

\section{Programmation dynamique}



% TODO partie "[pour] aller plus loin" ?

\section{Justification}
\label{sec:justification}

Bien que la justification de texte puisse poser des problèmes de lecture
\cite{Van96cognitive}, notamment à cause de l'insertion de nombreux espaces
entre les mots, ce qui peut créer des « rivières\footnote{En typographie, les
« rivières » (ou « lézardes ») sont des suites verticales d'espaces entre les
mots qui forment des chemins blancs dans le texte et distraient
l'œil\cite{Harkins12fr}} » et des trous blancs, il nous a parut intéressant de
nous pencher sur ce problème. La justification se fait une fois tous les mots
disposés sur les lignes en ajustant les espaces inter-mots de façon à ce que le
texte soit aligné aussi bien à gauche qu'à droite. Nous avons implémenté deux
méthodes :

\begin{enumerate}
    \item Méthode simple : Cette méthode fonctionne ligne par ligne. Elle
        calcule le nombre d'espaces en trop en fin de ligne et les répartie
        équitablement entre les mots de gauche à droite. Si le nombre d'espaces
        de fin de ligne n'est pas divisible par le nombre d'inter-mots, on
        ajoute un espace de plus au nombre nécessaire d'inter-mots de façon à ce
        qu'ils soient tous répartis. Cet algorithme de justification peut être
        utilisé sur la ligne de commande via l'option \verb|--justify simple|.
        Il ajoute une complexité en $O(2n)$ en temps (il passe une première fois
        sur une ligne pour calculer le nombre d'espaces à sa fin, puis une
        seconde pour les répartir, et ce pour chaque ligne), et $O(k)$ en
        mémoire puisqu'il ne garde qu'une seule ligne en mémoire à chaque fois.
    \item Méthode dynamique : Cette méthode regarde l'ensemble du paragraphe
        plutôt que ligne par ligne. Contrairement à la précédente qui laisse les
        mots sur leur ligne, elle peut déplacer des mots entre les lignes. Elle
        consiste à calculer la moyenne des largeurs des espaces entre mots de
        tout le texte si celui-ci était justifié avec la première méthode, puis
        de parcourir celui-ci pour ajuster les espaces afin de les rapprocher de
        la moyenne. Cet algorithme représente notre interprétation de la méthode
        de Hanan Samet\footnote{Hanan Samet propose plusieurs heuristiques pour
        déterminer l'uniformité d'un paragraphe, ainsi que des algorithmes pour
        l'améliorer. Nous ne nous sommes intéressés qu'aux heuristiques et avont
        implémenté un algorithme en s'inspirant de celles-ci} pour découper les
        lignes d'un texte \cite{Samet82}, et peut être utilisée sur la ligne de
        commande via l'option \verb|--justify dynamic|.
\end{enumerate}

\section{Récapitulatif}

% TODO tableau des benchmarks + récapitulatif des complexités

\newpage
\bibliographystyle{plain}
\bibliography{rapport}
\end{document}
